# Предложение по рефакторингу архитектуры в соответствии с принципами SOLID

## 1. Анализ текущих проблем

Текущая архитектура, хотя и функциональна, имеет несколько ключевых проблем, которые нарушают принципы SOLID:

- **Нарушение принципа единой ответственности (SRP):**
  - Интерфейс `IBuffer` и его реализация `RingBuffer` отвечают не только за хранение данных, но и за их чтение и запись из `std::ifstream` и `std::ofstream`. Это смешивает логику управления данными с логикой ввода-вывода.

- **Нарушение принципа инверсии зависимостей (DIP):**
  - Модули верхнего уровня (`ReaderJob`, `WriterJob`) напрямую зависят от низкоуровневых деталей реализации (`std::ifstream`, `std::ofstream`), которые передаются в `IBuffer`. Это делает систему жесткой и сложной для тестирования или расширения (например, для добавления поддержки чтения из сети).

## 2. Предлагаемая SOLID-архитектура

Новая архитектура будет основана на четком разделении ответственности, что сделает систему более гибкой, модульной и тестируемой.

### 2.1. Компоненты

#### `IDataSource` и `IDataSink`

- **Ответственность:** Абстрагирование от источников и приемников данных.
- **Описание:**
  - `IDataSource` будет предоставлять метод для чтения блока данных (например, `read(std::vector<char>& buffer)`).
  - `IDataSink` будет предоставлять метод для записи блока данных (например, `write(const std::vector<char>& data)`).
- **Примеры реализаций:**
  - `FileDataSource` / `FileDataSink` (для работы с файлами).
  - `IPCDataSource` / `IPCDataSink` (для работы с разделяемой памятью).
  - `NetworkDataSource` / `NetworkDataSink` (для работы с сетью).

#### `IDataProcessor`

- **Ответственность:** Обработка и хранение данных, а также управление синхронизацией.
- **Описание:**
  - Этот интерфейс заменит `IBuffer`. Он будет работать с сырыми данными (`std::vector<char>`), а не с потоками.
  - **Важно:** Вся логика синхронизации (мьютексы и т.д.) будет полностью инкапсулирована внутри реализаций этого интерфейса (например, `RingDataProcessor`). Это гарантирует, что существующий механизм потокобезопасности останется нетронутым и будет управляться в одном месте.
- **Методы:**
  - `process(const std::vector<char>& input)`: для записи данных в процессор.
  - `consume(std::vector<char>& output)`: для чтения данных из процессора.

#### `Worker`'ы (`ReaderWorker` и `WriterWorker`)

- **Ответственность:** Оркестрация потока данных.
- **Описание:**
  - `ReaderWorker` будет использовать `IDataSource` для чтения данных и `IDataProcessor` для их обработки/передачи.
  - `WriterWorker` будет получать данные из `IDataProcessor` и записывать их с помощью `IDataSink`.
  - Воркеры больше не будут знать о файлах, потоках или других деталях. Они будут работать исключительно с абстракциями.

### 2.2. Диаграмма взаимодействия

```
+--------------+       +-----------------+       +------------------+
| IDataSource  |------>|  ReaderWorker   |------>|  IDataProcessor  |
+--------------+       +-----------------+       +------------------+
      ^                      (владеет)                      ^
      |                                                     |
      |                                                     |
+--------------+       +-----------------+       +------------------+
| FileDataSource|      |   WriterWorker  |<------| (читает из)      |
+--------------+       +-----------------+       +------------------+
                           (владеет)
                                |
                                v
                         +--------------+
                         |   IDataSink  |
                         +--------------+
                                ^
                                |
                         +--------------+
                         |  FileDataSink |
                         +--------------+

```

## 3. Преимущества новой архитектуры

- **Гибкость (Open/Closed Principle):** Систему можно легко расширить, добавив новые источники или приемники данных (например, для сети), не изменяя существующие воркеры или процессоры.
- **Тестируемость:** Каждый компонент можно тестировать в изоляции, подменяя зависимости "моками" (например, можно протестировать `ReaderWorker`, подставив ему `MockDataSource`).
- **Надежность (Single Responsibility Principle):** Каждый класс имеет одну, четко определенную зону ответственности, что упрощает его понимание и поддержку.
